#!/usr/bin/env python3
import argparse, json, socket, ssl
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional

import dns.resolver
import requests
import whois

TIMEOUT = 6
UA = "ScamAdvisoryEmailDiag/1.0 (+https://scamadvisory.co.uk)"

def to_iso(dt) -> Optional[str]:
    if isinstance(dt, list) and dt:
        dt = dt[0]
    if isinstance(dt, datetime):
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc).isoformat()
    if isinstance(dt, str):
        return dt
    return None

def parse_iso_date(s: Optional[str]) -> Optional[datetime]:
    if not s:
        return None
    try:
        # Accept isoformat from to_iso(), else try broad parse
        return datetime.fromisoformat(s.replace("Z", "+00:00"))
    except Exception:
        try:
            # Some WHOIS return bare dates; last-resort
            return datetime.strptime(s, "%Y-%m-%d").replace(tzinfo=timezone.utc)
        except Exception:
            return None

def domain_from_email(email: str) -> str:
    if "@" not in email:
        raise ValueError("Provide an email like name@example.com")
    return email.split("@", 1)[1].strip().lower()

def whois_domain_min(domain: str) -> Dict[str, Any]:
    try:
        w = whois.whois(domain)
        domain_name = w.domain_name[0] if isinstance(w.domain_name, list) else w.domain_name
        return {
            "domain_name": domain_name,
            "registrar": w.registrar,
            "creation_date": to_iso(w.creation_date),
            "expiration_date": to_iso(w.expiration_date),
        }
    except Exception as e:
        return {"error": f"domain whois failed: {e.__class__.__name__}: {e}"}

def resolve_A(domain: str) -> List[str]:
    try:
        r = dns.resolver.Resolver(); r.timeout = r.lifetime = TIMEOUT
        return [a.to_text() for a in r.resolve(domain, "A")]
    except Exception:
        return []

def ip_geo_min(ip: str) -> Dict[str, Any]:
    try:
        r = requests.get(
            f"http://ip-api.com/json/{ip}",
            params={"fields":"status,message,country,regionName,city,lat,lon,isp,org"},
            headers={"User-Agent": UA}, timeout=TIMEOUT
        )
        j = r.json()
        if j.get("status") != "success":
            return {"error": f"geo failed: {j.get('message')}"}
        return {
            "country": j.get("country"),
            "region": j.get("regionName"),
            "city": j.get("city"),
            "lat": j.get("lat"),
            "lon": j.get("lon"),
            "isp": j.get("isp"),
            "org": j.get("org"),
        }
    except Exception as e:
        return {"error": f"geo failed: {e.__class__.__name__}: {e}"}

def parse_name_tuple_list(tuples: List[tuple]) -> Dict[str, str]:
    out = {}
    for k, v in tuples:
        out[k] = v
    return out

def parse_cert_min(cert: Dict[str, Any]) -> Dict[str, Any]:
    issuer = {}
    for rdn in cert.get("issuer", []) or []:
        issuer.update(parse_name_tuple_list(rdn))
    not_after = cert.get("notAfter")

    def parse_dt(s):
        try:
            return datetime.strptime(s, "%b %d %H:%M:%S %Y %Z").replace(tzinfo=timezone.utc).isoformat()
        except Exception:
            return s

    issuer_cn = issuer.get("commonName")
    issuer_o = issuer.get("organizationName")
    is_le = ("Let's Encrypt" in (issuer_cn or "")) or ("Let's Encrypt" in (issuer_o or ""))

    subject = {}
    for rdn in cert.get("subject", []) or []:
        subject.update(parse_name_tuple_list(rdn))
    is_self = bool(subject and issuer and subject == issuer)

    return {
        "issuer": {
            "countryName": issuer.get("countryName"),
            "organizationName": issuer_o,
            "commonName": issuer_cn,
            "not_after": parse_dt(not_after) if not_after else None,
            "is_self_signed": is_self,
            "issuer_summary": issuer_cn or issuer_o,
            "is_lets_encrypt": is_le,
        }
    }

def tls_probe(host: str, port: int = 443) -> Dict[str, Any]:
    out = {"ssl": {"tls_valid": False}}
    # Verified first
    try:
        ctx = ssl.create_default_context()
        with socket.create_connection((host, port), timeout=TIMEOUT) as sock:
            with ctx.wrap_socket(sock, server_hostname=host) as ssock:
                out["ssl"]["tls_valid"] = True
                cert = ssock.getpeercert()
                out.update(parse_cert_min(cert))
                return out
    except Exception:
        pass
    # Fallback: unverified (to still report issuer)
    try:
        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        ctx.check_hostname = False; ctx.verify_mode = ssl.CERT_NONE
        with socket.create_connection((host, port), timeout=TIMEOUT) as sock:
            with ctx.wrap_socket(sock, server_hostname=host) as ssock:
                cert = ssock.getpeercert()
                out.update(parse_cert_min(cert))
    except Exception:
        pass
    return out

def compute_risk(whois_min: Dict[str, Any], ssl_min: Dict[str, Any]) -> Dict[str, Any]:
    """Return {risk_score, risk_label, signals[]} based on domain age & SSL."""
    score = 0
    signals = []

    # Domain age
    creation_iso = whois_min.get("creation_date")
    created_dt = parse_iso_date(creation_iso) if creation_iso else None
    now = datetime.now(timezone.utc)
    if not created_dt:
        score += 10
        signals.append({"signal": "missing_creation_date", "impact": +10})
        age_days = None
    else:
        age_days = (now - created_dt).days
        if age_days < 7:
            score += 40; signals.append({"signal": "age_<7d", "impact": +40, "age_days": age_days})
        elif age_days < 90:
            score += 25; signals.append({"signal": "age_7d_to_3m", "impact": +25, "age_days": age_days})
        elif age_days < 180:
            score += 12; signals.append({"signal": "age_3m_to_6m", "impact": +12, "age_days": age_days})
        elif age_days < 365:
            score += 5;  signals.append({"signal": "age_6m_to_12m", "impact": +5, "age_days": age_days})
        else:
            score -= 15; signals.append({"signal": "age_>12m", "impact": -15, "age_days": age_days})

    # SSL
    tls_valid = ssl_min.get("ssl", {}).get("tls_valid", False)
    issuer = ssl_min.get("issuer", {}) if "issuer" in ssl_min else {}
    is_self = bool(issuer.get("is_self_signed"))
    is_le = bool(issuer.get("is_lets_encrypt"))

    if not tls_valid:
        score += 40; signals.append({"signal": "tls_invalid_or_absent", "impact": +40})
    else:
        if not is_le:
            # Valid TLS, non-LE â†’ a small positive signal
            score -= 10; signals.append({"signal": "tls_valid_non_LE", "impact": -10})

    if is_self:
        score += 30; signals.append({"signal": "self_signed", "impact": +30})

    if is_le:
        # Ensure LE is at least Medium even for old domains: +45 base
        le_impact = 45
        if created_dt and (now - created_dt).days < 90:
            le_impact += 10  # extra risk if very new
        score += le_impact
        signals.append({"signal": "lets_encrypt", "impact": le_impact})

    # Clamp & label
    score = max(0, min(100, score))
    if score >= 75:
        label = "Critical"
    elif score >= 50:
        label = "High"
    elif score >= 25:
        label = "Medium"
    else:
        label = "Low"

    return {"risk_score": score, "risk_label": label, "signals": signals}




def diag(email: str, verbose: bool = False) -> Dict[str, Any]:
    domain = domain_from_email(email)

    whois_min = whois_domain_min(domain)

    # choose probe host (apex if it has A; else www.)
    A = resolve_A(domain)
    probe_host = domain if A else f"www.{domain}"
    ssl_min = tls_probe(probe_host)

    # Just the first IP's geo details (if any)
    ip_details = []
    if A:
        ip = A[0]
        ip_details.append({"ip": ip, "geo": ip_geo_min(ip)})

    minimal = {
        "input_email": email,
        "domain": domain,
        "domain_whois": whois_min,
        **ssl_min,                 # {"ssl": {...}, "issuer": {...}}
        "ip_details": ip_details,
    }

    # Add risk
    minimal.update(compute_risk(whois_min, ssl_min))

    if not verbose:
        return minimal

    # ---- VERBOSE ADD-ONS ----
    verbose_blob: Dict[str, Any] = {}
    r = dns.resolver.Resolver(); r.timeout = r.lifetime = TIMEOUT
    def safe_resolve(name, rtype):
        try:
            return [x.to_text() for x in r.resolve(name, rtype)]
        except Exception:
            return []
    verbose_blob["dns"] = {
        "A": A,
        "AAAA": safe_resolve(domain, "AAAA"),
        "MX": [{"preference": rr.preference, "host": str(rr.exchange).rstrip(".")}
               for rr in r.resolve(domain, "MX")] if safe_resolve(domain, "MX") else []
    }

    try:
        full_w = whois.whois(domain)
        verbose_blob["domain_whois_full"] = {k: (v if k != "text" else None) for k, v in full_w.__dict__.items()}
    except Exception as e:
        verbose_blob["domain_whois_full_error"] = str(e)

    return {**minimal, **verbose_blob}

def main():
    ap = argparse.ArgumentParser(description="Email diagnostics (minimal output + risk score).")
    ap.add_argument("email")
    ap.add_argument("--verbose", action="store_true", help="Output extended diagnostics")
    args = ap.parse_args()

    data = diag(args.email, verbose=args.verbose)
    print(json.dumps(data, ensure_ascii=False, indent=2))

if __name__ == "__main__":
    main()

